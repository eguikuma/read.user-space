---
layout: default
title: なぜ8と16なのか
---

# [なぜ8と16なのか](#why-8-and-16) {#why-8-and-16}

## [はじめに](#introduction) {#introduction}

[05-file-descriptor](../../05-file-descriptor/) で、こんなコードを見ました

```c
int fd = open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
```

`0644` とは何でしょうか

なぜ `644` ではなく `0644` なのでしょうか

また、デバッグでメモリアドレスを見ると `0x7fffffffde40` のような値が出てきます

なぜ `0x` で始まるのでしょうか

このドキュメントでは、8進数と16進数が「なぜ」使われるのかを説明します

---

## [目次](#table-of-contents) {#table-of-contents}

- [なぜ8と16なのか](#why-8-and-16-detail)
- [表記法](#notation)
- [読み方・変換](#reading-and-conversion)
- [実例](#examples)
- [まとめ](#summary)
- [参考資料](#references)

---

## [なぜ8と16なのか](#why-8-and-16-detail) {#why-8-and-16-detail}

### [コンピュータは2進数、人間は10進数](#binary-vs-decimal) {#binary-vs-decimal}

コンピュータは内部で「0 と 1」だけを使います

これが<strong>2進数</strong>です

一方、人間は「0 から 9」の10進数に慣れています

しかし、2進数は桁が多くて読みにくいです

```
10進数:  255
2進数:   11111111  ← 8桁も必要
```

### [8と16は2進数と相性が良い](#octal-hex-compatibility) {#octal-hex-compatibility}

<strong>8 = 2³</strong> です

つまり、8進数の1桁は2進数の3桁（3ビット）に対応します

<strong>16 = 2⁴</strong> です

つまり、16進数の1桁は2進数の4桁（4ビット）に対応します

```
2進数:   111  = 7   （8進数で 7）
2進数:  1111  = 15  （16進数で F）
```

この「きれいに対応する」性質が、8進数と16進数が使われる理由です

<strong>もし 10 進数だけを使っていたら？</strong>

{: .labeled}
| 用途 | 16進数 | 10進数 | 問題 |
| -------------- | ------ | ------ | ---------------------------- |
| 1バイト | 0xFF | 255 | 桁数が揃わない |
| 2バイト | 0xFFFF | 65535 | バイト境界が見えない |
| パーミッション | 0644 | 420 | rwx の組み合わせが分からない |

10 進数の「255」を見ても、ビットパターンは分かりません

16 進数の「0xFF」を見れば、「全ビットが 1」と即座に分かります

### [視覚的に理解する](#visual-understanding) {#visual-understanding}

<strong>16進数の場合（4ビットごと）</strong>

```
2進数:    1111 1111
          ─────────
16進数:     F    F   → 0xFF
```

<strong>8進数の場合（3ビットごと）</strong>

```
2進数:    110 100 100
          ───────────
8進数:      6   4   4  → 0644
```

10進数ではこのような「きれいな対応」ができません

---

## [表記法](#notation) {#notation}

### [なぜ 0x で始まるのか（16進数）](#why-0x-prefix-hexadecimal) {#why-0x-prefix-hexadecimal}

C 言語では、16進数リテラルは `0x` または `0X` で始まります

```c
/*
 * 255
 */
int a = 0xFF;
/*
 * 16
 */
int b = 0x10;
/*
 * 57005
 */
int c = 0xDEAD;
```

<strong>由来</strong>

「x」は「hexadecimal（16進数）」の略です

「0」を先頭に置くことで、変数名と区別できます

`xFF` だと変数名に見えてしまいます

### [なぜ 0 で始まるのか（8進数）](#why-0-prefix-octal) {#why-0-prefix-octal}

C 言語では、8進数リテラルは `0` で始まります

```c
/*
 * 420（10進数）
 */
int a = 0644;
/*
 * 511（10進数）
 */
int b = 0777;
/*
 * 8（10進数）
 */
int c = 010;
```

<strong>由来</strong>

UNIX や C 言語が生まれた時代、8進数は頻繁に使われていました

短くて打ちやすい `0` が選ばれました

<strong>注意</strong>

```c
/*
 * これは 8 であって 10 ではない！
 */
int x = 010;
```

意図せず8進数になることがあるので、注意が必要です

### [2進数リテラル（C23 以降）](#binary-literal-c23) {#binary-literal-c23}

C23（2024年に策定された C 言語の最新規格）からは `0b` で2進数を書けるようになりました

```c
/*
 * 15
 */
int a = 0b1111;
/*
 * 10
 */
int b = 0b1010;
```

{: .labeled}
| 表記 | 進数 | 例 | 10進数での値 |
| ---- | ------ | -------- | ------------ |
| `0x` | 16進数 | `0xFF` | 255 |
| `0` | 8進数 | `0644` | 420 |
| `0b` | 2進数 | `0b1111` | 15 |
| なし | 10進数 | `255` | 255 |

---

## [読み方・変換](#reading-and-conversion) {#reading-and-conversion}

### [16進数の読み方](#reading-hexadecimal) {#reading-hexadecimal}

16進数は「0 ～ 9」と「A ～ F」を使います

{: .labeled}
| 16進数 | 10進数 | 2進数 |
| ------ | ------ | ----- |
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| A | 10 | 1010 |
| B | 11 | 1011 |
| C | 12 | 1100 |
| D | 13 | 1101 |
| E | 14 | 1110 |
| F | 15 | 1111 |

<strong>例：0x7FFF を読む</strong>

```
0x7FFF
  │││└─ F = 1111
  ││└── F = 1111
  │└─── F = 1111
  └──── 7 = 0111

2進数: 0111 1111 1111 1111
10進数: 32767
```

### [8進数の読み方](#reading-octal) {#reading-octal}

8進数は「0 ～ 7」を使います

{: .labeled}
| 8進数 | 10進数 | 2進数 |
| ----- | ------ | ----- |
| 0 | 0 | 000 |
| 1 | 1 | 001 |
| 2 | 2 | 010 |
| 3 | 3 | 011 |
| 4 | 4 | 100 |
| 5 | 5 | 101 |
| 6 | 6 | 110 |
| 7 | 7 | 111 |

<strong>例：0644 を読む</strong>

```
0644
 │││
 ││└─ 4 = 100
 │└── 4 = 100
 └─── 6 = 110

2進数: 110 100 100
10進数: 420
```

---

## [実例](#examples) {#examples}

### [パーミッション（0644）── なぜ8進数か](#permissions-0644-why-octal) {#permissions-0644-why-octal}

UNIX のファイルパーミッションは「所有者・グループ・その他」の3つに分かれています

それぞれ「読み（r）・書き（w）・実行（x）」の3ビットを持ちます

```
rwx rwx rwx
─── ─── ───
所有者 グループ その他
```

3ビット = 8進数1桁なので、パーミッションは8進数で表すのが自然です

<strong>0644 の意味</strong>

```
0644
 │││
 ││└─ 4 = 100 = r--  （その他：読み取りのみ）
 │└── 4 = 100 = r--  （グループ：読み取りのみ）
 └─── 6 = 110 = rw-  （所有者：読み書き）
```

{: .labeled}
| 数字 | 2進数 | 意味 |
| ---- | ----- | ---- |
| 0 | 000 | --- |
| 1 | 001 | --x |
| 2 | 010 | -w- |
| 3 | 011 | -wx |
| 4 | 100 | r-- |
| 5 | 101 | r-x |
| 6 | 110 | rw- |
| 7 | 111 | rwx |

### [メモリアドレス（0x7fff...）── なぜ16進数か](#memory-address-why-hexadecimal) {#memory-address-why-hexadecimal}

メモリアドレスは通常、バイト単位で扱います

1バイト = 8ビット = 16進数2桁です

```
1バイト:    00000000 ～ 11111111
16進数:     0x00     ～ 0xFF
```

16進数なら、バイト境界がきれいに見えます

<strong>例：64ビットアドレス</strong>

```
16進数: 0x7FFFFFFFDE40
          ││││││││││││
          └┴┴┴┴┴┴┴┴┴┴┴─ 8バイト = 16桁

10進数: 140737488346688  ← 読みにくい
```

メモリダンプでも16進数が使われます

```
アドレス         内容（16進数）
0x7fffffffde40:  48 65 6c 6c 6f 00     "Hello\0"
```

---

## [まとめ](#summary) {#summary}

{: .labeled}
| 進数 | 使われる場面 | 理由 |
| ------ | ------------------------ | ---------------------------- |
| 8進数 | パーミッション | 3ビット（rwx）が1桁に対応 |
| 16進数 | メモリアドレス、バイト値 | 4ビット（ニブル）が1桁に対応 |
| 2進数 | ビット演算の説明 | 直接ビットが見える |
| 10進数 | 一般的な計算 | 人間が読みやすい |

<strong>覚えておくこと</strong>

- `0x` で始まれば16進数
- `0` で始まれば8進数（ただし `0x` を除く）
- `0b` で始まれば2進数（C23 以降）
- 8 = 2³、16 = 2⁴ なので、2進数ときれいに対応する

---

## [参考資料](#references) {#references}

<strong>C 言語規格</strong>

- ISO/IEC 9899:2024（C23）─ 6.4.4.1 Integer constants
- [cppreference: Integer literal](https://en.cppreference.com/w/c/language/integer_constant){:target="\_blank"}

<strong>UNIX パーミッション</strong>

- [POSIX chmod](https://pubs.opengroup.org/onlinepubs/9699919799/functions/chmod.html){:target="\_blank"}
- [Man page: chmod(2)](https://man7.org/linux/man-pages/man2/chmod.2.html){:target="\_blank"}

<strong>本編との関連</strong>

- [05-file-descriptor](../../05-file-descriptor/) ─ `open()` の第3引数でパーミッションを指定
