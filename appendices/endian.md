<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# なぜhtonl()が必要なのか

## はじめに

[07-ipc](../07-ipc.md) で、UNIX ドメインソケットを学びました

UNIX ドメインソケットは「ネットワークプログラミングへの橋渡し」と説明しました

では、実際にネットワーク越しに通信するとき、何に気をつける必要があるでしょうか？

その一つが<strong>バイトオーダー（バイト順序）</strong>の問題です

```c
struct sockaddr_in addr;
/*
 * なぜ htons() が必要？
 */
addr.sin_port = htons(8080);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
```

結論から言うと、<strong>CPU によってバイトの並び順が異なるため、ネットワーク通信では統一された順序に変換する必要がある</strong>のです

---

## 目次

- [エンディアンとは何か](#エンディアンとは何か)
- [なぜhtonl()が必要なのか](#なぜhtonlが必要なのか)
- [バイトオーダー変換関数](#バイトオーダー変換関数)
- [自分の環境のエンディアンを確認する](#自分の環境のエンディアンを確認する)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## エンディアンとは何か

### バイトの並び順

<strong>エンディアン</strong>とは、複数バイトのデータをメモリに格納するときの「バイトの並び順」のことです

例えば、32 ビット（4 バイト）の整数 `0x12345678` をメモリに格納することを考えます

この値は 4 つのバイトで構成されています

```
0x12345678 の 4 バイト
─── 0x12（最上位バイト：MSB）
─── 0x34
─── 0x56
─── 0x78（最下位バイト：LSB）
```

<strong>MSB</strong> は Most Significant Byte（最上位バイト）の略です

<strong>LSB</strong> は Least Significant Byte（最下位バイト）の略です

### ビッグエンディアンとリトルエンディアン

エンディアンには 2 種類あります

<strong>ビッグエンディアン</strong>

最上位バイト（MSB）を先に（低いアドレスに）格納する方式です

```
メモリアドレス:  0x00  0x01  0x02  0x03
格納される値:    0x12  0x34  0x56  0x78
                 ↑
                 最上位バイトが先
```

人間が数値を読む順序と同じなので、直感的です

<strong>リトルエンディアン</strong>

最下位バイト（LSB）を先に（低いアドレスに）格納する方式です

```
メモリアドレス:  0x00  0x01  0x02  0x03
格納される値:    0x78  0x56  0x34  0x12
                 ↑
                 最下位バイトが先
```

人間には読みにくいですが、CPU にとっては処理しやすい場合があります

### 主要な CPU アーキテクチャ

現在使われている主要な CPU は、ほとんどがリトルエンディアンです

| アーキテクチャ    | エンディアン       |
| ----------------- | ------------------ |
| x86 / x86-64      | リトルエンディアン |
| ARM（デフォルト） | リトルエンディアン |
| Apple Silicon     | リトルエンディアン |
| RISC-V            | リトルエンディアン |
| ネットワーク      | ビッグエンディアン |

※ ARM は bi-endian（両方に対応可能）ですが、実用上はリトルエンディアンがデフォルトです

ネットワーク通信では<strong>ビッグエンディアン</strong>が標準として採用されています

これを<strong>ネットワークバイトオーダー</strong>といいます

### なぜ 2 種類のエンディアンが存在するのか

<strong>歴史的背景</strong>

1960〜70 年代、各 CPU メーカーは独自の判断でエンディアンを決定しました

| 時代     | メーカー | エンディアン | 理由                               |
| -------- | -------- | ------------ | ---------------------------------- |
| 1960年代 | IBM      | ビッグ       | 人間が読みやすい順序               |
| 1970年代 | Intel    | リトル       | 加算時に下位バイトから処理しやすい |
| 1980年代 | ARM      | 両対応       | 互換性のため                       |

<strong>リトルエンディアンの技術的利点</strong>

- 加算・乗算で下位バイトから処理するときに都合が良い
- 型のサイズを変更しても先頭アドレスが変わらない

<strong>ビッグエンディアンの技術的利点</strong>

- 人間がデバッグしやすい（メモリダンプが読みやすい）
- 比較操作が先頭バイトから行える

<strong>なぜネットワークはビッグエンディアンなのか</strong>

インターネットの標準化（1970年代後半）の時点で、多くのネットワーク機器がビッグエンディアンの CPU を使っていました

また、ビッグエンディアンは人間が読みやすく、プロトコル仕様書の記述と一致するため、標準として採用されました

### 語源

「エンディアン」という名前は、ジョナサン・スウィフトの小説『ガリバー旅行記』に由来します

作中で、卵を「大きい端（big end）から割る派」と「小さい端（little end）から割る派」が争う話があります

どちらの端からバイトを並べるかという議論が、この争いに似ていることから名付けられました

---

## なぜhtonl()が必要なのか

### 問題：CPU によってバイト順が異なる

異なるエンディアンの CPU 間でデータをやり取りすると、値が正しく解釈されません

例えば、ポート番号 `8080`（0x1F90）を送信する場合を考えます

```
送信側（リトルエンディアン CPU）
─── メモリ上の配置：0x90 0x1F
─── そのままネットワークに送信

受信側（ビッグエンディアン CPU）
─── 受信したデータ：0x90 0x1F
─── ビッグエンディアンとして解釈：0x901F = 36895
─── 本来の 8080 とは全く違う値！
```

### 解決策：ネットワークバイトオーダー

この問題を解決するため、ネットワーク通信では<strong>ネットワークバイトオーダー（ビッグエンディアン）</strong>を使うことが標準化されています

インターネット標準で「ネットワーク上のデータはビッグエンディアンで表現する」と定められています

```
送信時
─── ホストバイトオーダー → ネットワークバイトオーダーに変換
─── htonl()、htons() を使用

受信時
─── ネットワークバイトオーダー → ホストバイトオーダーに変換
─── ntohl()、ntohs() を使用
```

### 使用例

TCP/IP ソケットプログラミングでは、IP アドレスやポート番号を設定するときに変換が必要です

```c
#include <arpa/inet.h>
#include <netinet/in.h>

struct sockaddr_in server_addr;

/* ポート番号（16 ビット）を変換 */
server_addr.sin_port = htons(8080);

/* IP アドレス（32 ビット）を変換 */
server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
```

`INADDR_ANY` は「すべてのネットワークインターフェースで接続を受け付ける」という意味の特別な値です

---

## バイトオーダー変換関数

### 4 つの変換関数

`<arpa/inet.h>` ヘッダで定義されている 4 つの関数があります

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);   /* host to network long */
uint16_t htons(uint16_t hostshort);  /* host to network short */
uint32_t ntohl(uint32_t netlong);    /* network to host long */
uint16_t ntohs(uint16_t netshort);   /* network to host short */
```

### 関数名の覚え方

関数名は略語の組み合わせです

| 略語 | 意味               |
| ---- | ------------------ |
| h    | host（ホスト）     |
| n    | network            |
| to   | ～へ変換           |
| l    | long（32 ビット）  |
| s    | short（16 ビット） |

```
htonl = host to network long
─── ホストのバイト順 → ネットワークのバイト順（32 ビット）

ntohs = network to host short
─── ネットワークのバイト順 → ホストのバイト順（16 ビット）
```

### 使い分け

| 用途                       | 関数          |
| -------------------------- | ------------- |
| ポート番号（16 ビット）    | htons / ntohs |
| IPv4 アドレス（32 ビット） | htonl / ntohl |

### ビッグエンディアン環境では何もしない

すでにビッグエンディアンの環境では、ホストバイトオーダーとネットワークバイトオーダーが同じです

そのため、これらの関数は「何もしない」動作になります

```c
/* ビッグエンディアン環境では */
htonl(x) == x  /* 変換不要なのでそのまま返す */
```

これにより、同じコードがどちらのエンディアンでも正しく動作します

---

## 自分の環境のエンディアンを確認する

### 方法 1：union を使う

C99 以降では、union を使った方法が一般的です

```c
#include <stdio.h>
#include <stdint.h>

int main(void)
{
    union {
        uint32_t value;
        uint8_t bytes[4];
    } test = {0x01020304};

    if (test.bytes[0] == 1) {
        printf("ビッグエンディアン\n");
    } else {
        printf("リトルエンディアン\n");
    }

    printf("メモリ配置：");
    for (int i = 0; i < 4; i++) {
        printf("0x%02x ", test.bytes[i]);
    }
    printf("\n");

    return 0;
}
```

実行結果（x86-64 環境）

```
リトルエンディアン
メモリ配置：0x04 0x03 0x02 0x01
```

### 方法 2：ポインタキャストを使う

より簡潔な方法です

```c
#include <stdio.h>

int main(void)
{
    unsigned int x = 1;
    char *c = (char *)&x;

    if (*c == 1) {
        printf("リトルエンディアン\n");
    } else {
        printf("ビッグエンディアン\n");
    }

    return 0;
}
```

`x = 1` をメモリに格納したとき、最下位バイト（0x01）がどこに置かれるかを確認しています

リトルエンディアンなら最下位バイトが先頭（低いアドレス）に来るため、`*c == 1` になります

### 方法 3：htonl() を使う

ネットワーク関数を使った確認方法です

```c
#include <stdio.h>
#include <arpa/inet.h>

int main(void)
{
    uint32_t test = 1;

    if (htonl(test) == test) {
        printf("ビッグエンディアン\n");
    } else {
        printf("リトルエンディアン\n");
    }

    return 0;
}
```

ビッグエンディアン環境では `htonl()` は何もしないため、元の値と同じになります

---

## まとめ

| 用語                       | 意味                                      |
| -------------------------- | ----------------------------------------- |
| エンディアン               | 複数バイトのデータをメモリに格納する順序  |
| ビッグエンディアン         | 最上位バイトを先に格納する方式            |
| リトルエンディアン         | 最下位バイトを先に格納する方式            |
| ネットワークバイトオーダー | ネットワーク通信で使う標準順序（ビッグ）  |
| htonl() / htons()          | ホスト → ネットワークバイトオーダーに変換 |
| ntohl() / ntohs()          | ネットワーク → ホストバイトオーダーに変換 |

<strong>覚えておくこと</strong>

- 現在の主要な CPU（x86、ARM）はリトルエンディアン
- ネットワーク通信ではビッグエンディアン（ネットワークバイトオーダー）が標準
- TCP/IP プログラミングでは htonl()、htons()、ntohl()、ntohs() で変換が必要
- これらの関数を使えば、エンディアンの違いを意識せずにコードを書ける

---

## 参考資料

<strong>Linux マニュアル</strong>

- [htonl(3p) - Linux manual page](https://man7.org/linux/man-pages/man3/htonl.3p.html)
  - POSIX 準拠のバイトオーダー変換関数
- [byteorder(3) - Linux manual page](https://man7.org/linux/man-pages/man3/htons.3.html)
  - Linux でのバイトオーダー変換関数

<strong>GNU C Library</strong>

- [Byte Order - GNU C Library](https://sourceware.org/glibc/manual/latest/html_node/Byte-Order.html)
  - バイトオーダー変換関数の公式ドキュメント

<strong>本編との関連</strong>

- [07-ipc](../07-ipc.md)
  - UNIX ドメインソケットの基礎
  - ネットワークプログラミングへの橋渡し
