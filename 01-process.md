<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 01-process：プロセスとは何か

## はじめに

「プロセス」という言葉を聞いたことはありますか？

Windows を使っている方なら、`Ctrl + Alt + Delete` を押して「タスクマネージャー」を開いたことがあるかもしれません

そこに並んでいる「Chrome」「Word」「Spotify」などの一覧

あれが「プロセス」です

Mac を使っている方なら、「アクティビティモニタ」で見られます

<strong>一言で言うと、プロセスとは「実行中のプログラム」のこと</strong>です

### 日常の例え

プログラムとプロセスの関係は、「料理のレシピ」と「実際に料理を作っている状態」に似ています

レシピ（プログラム）は本棚にあるだけでは、何も起きません

キッチンに立って材料を用意し、火を使って調理を始めたとき、それが「プロセス」です

同じレシピから、同時に 2 つの料理を作ることもできます（2 つのプロセス）

このページでは、「プロセス」とは具体的に何なのかを、基礎から詳しく学びます

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>プログラムとプロセスの違い</strong>
  - ファイルとして保存されている設計図と、実行中の実体の違い
- <strong>プロセスが持つもの</strong>
  - PID、メモリ空間、ファイルディスクリプタ、環境変数など
- <strong>プロセスの親子関係</strong>
  - すべてのプロセスには親がいる
- <strong>プロセスの状態</strong>
  - Running、Sleeping、Zombie など
- <strong>/proc ファイルシステム</strong>
  - プロセス情報を観察する方法
- <strong>メモリの構造</strong>
  - テキスト、データ、ヒープ、スタック
- <strong>環境変数と作業ディレクトリ</strong>
  - プロセスの実行環境

---

## 目次

1. [なぜ「プロセス」という概念が必要なのか](#なぜプロセスという概念が必要なのか)
2. [プログラムとプロセスの違い](#プログラムとプロセスの違い)
3. [プロセスが持つもの](#プロセスが持つもの)
4. [プロセス ID（PID）とは](#プロセス-idpidとは)
5. [プロセスの親子関係](#プロセスの親子関係)
6. [プロセスの状態](#プロセスの状態)
7. [プロセスを観察してみよう](#プロセスを観察してみよう)
8. [/proc ファイルシステム](#proc-ファイルシステム)
9. [メモリの構造](#メモリの構造)
10. [環境変数](#環境変数)
11. [作業ディレクトリ](#作業ディレクトリ)
12. [用語集](#用語集)
13. [参考資料](#参考資料)

---

## なぜ「プロセス」という概念が必要なのか

まず根本的な疑問に答えましょう

なぜ OS は「プロセス」という概念を作ったのでしょうか？

### もしプロセスという概念がなかったら？

すべてのプログラムが<strong>同じメモリ空間</strong>で動くとどうなるでしょうか

<strong>問題 1：1 つのプログラムのバグが全体を巻き込む</strong>

あるプログラムが誤って別のプログラムのメモリを書き換えてしまいます

その結果、関係のないプログラムがクラッシュしたり、おかしな動作をします

<strong>問題 2：セキュリティが保てない</strong>

どのプログラムも、他のプログラムのデータを自由に読めてしまいます

パスワード管理ソフトのデータを、悪意のあるプログラムが盗み見ることができます

<strong>問題 3：1 つのプログラムの暴走が全体を止める</strong>

無限ループに陥ったプログラムがあると、他のプログラムも動けなくなります

強制終了しようにも、どこからどこまでがそのプログラムなのか区別できません

### プロセスが解決すること

OS はプログラムを「プロセス」という単位で<strong>隔離</strong>します

各プロセスは

- 自分専用のメモリ空間を持つ（他のプロセスから見えない）
- 独立して実行・停止できる（他のプロセスに影響しない）
- 個別に権限を設定できる（セキュリティを確保）

これにより、1 つのプログラムの問題が他に波及することを防いでいます

---

## プログラムとプロセスの違い

この2つは似ているようで、まったく異なります

### プログラムとは

<strong>プログラム</strong>は、ディスク（SSD や HDD）に保存されている「ファイル」です

例えば、`/usr/bin/ls` というファイルがあります

これは `ls` コマンドのプログラムです

プログラムは

- ファイルとして保存されている
- 実行されるまでは「ただのデータ」
- 何度実行しても、ファイル自体は変わらない

料理で例えると、<strong>レシピ</strong>（料理本に書かれた手順）に相当します

### プロセスとは

<strong>プロセス</strong>は、プログラムを実行したときに生まれる「実体」です

例えば、ターミナルで `ls` と打つと、プロセスが1つ生まれます

プロセスは

- メモリ上に存在する
- 実行中は常に状態が変化する
- 終了すると消える

料理で例えると、<strong>実際に料理を作っている状態</strong>に相当します

### 比較表

| 項目 | プログラム         | プロセス                   |
| ---- | ------------------ | -------------------------- |
| 何か | ファイル（設計図） | 実行中の実体               |
| 場所 | ディスク上         | メモリ上                   |
| 状態 | 変化しない         | 常に変化する               |
| 寿命 | 削除するまで存在   | 終了すると消える           |
| 例え | 料理のレシピ       | 実際に料理を作っている状態 |

### 重要なポイント

1つのプログラムから、複数のプロセスを作ることができます

例えば、ブラウザを2つのウィンドウで開くと、同じプログラムから2つのプロセスが生まれます

---

## プロセスが持つもの

プロセスは、単に「実行中のコード」だけではありません

OS はプロセスごとに、以下のものを管理しています

### 1. プロセス ID（PID）

すべてのプロセスには、OS が割り当てる<strong>一意</strong>（唯一無二、他と重複しない）の番号があります

同時に同じ番号を持つプロセスは存在しません

詳しくは[次のセクション](#プロセス-idpidとは)で説明します

### 2. メモリ空間

プロセスは、自分専用のメモリ領域を持っています

他のプロセスのメモリに直接アクセスすることはできません

詳しくは[メモリの構造](#メモリの構造)で説明します

### 3. ファイルディスクリプタ

プロセスが開いているファイルを識別する「番号」です

#### 「ファイルを開く」とは

プログラムがファイルを読み書きするとき、まず OS に「このファイルを使いたい」と伝えます

この操作を「ファイルを開く」と呼びます

GUI（Windows のエクスプローラーなど）でファイルをダブルクリックして「開く」のとは少し違います

GUI の「開く」は、アプリを起動してファイルを表示することです

プログラミングの「開く」は、OS にファイルへのアクセス許可をもらうことです

詳しくは [05-file-descriptor](./05-file-descriptor.md) で学びます

#### ファイルディスクリプタとは

<strong>ファイルディスクリプタ（fd）</strong>とは、プロセスが開いたファイルに対して OS が割り当てる整数値です

プログラムはこの番号を使って、ファイルの読み書きを行います

「ファイル」には、通常のファイルだけでなく、ネットワーク接続や<strong>パイプ</strong>（プロセス間でデータをやり取りする仕組み、[07-ipc](./07-ipc.md) で学習）なども含まれます

すべてのプロセスは起動時に、以下の 3 つのファイルディスクリプタを持っています

- <strong>0（標準入力 / stdin）</strong>
  - キーボードからの入力を受け取ります
- <strong>1（標準出力 / stdout）</strong>
  - 画面への出力に使われます
- <strong>2（標準エラー出力 / stderr）</strong>
  - エラーメッセージ用の出力です

新しくファイルを開くと、3 以降の番号が割り当てられます

### 4. 環境変数

プロセスに渡される「設定情報」のようなものです

詳しくは[環境変数](#環境変数)で説明します

### 5. 作業ディレクトリ

プロセスが「今いる場所」です

今いる場所からの位置（./file.txt など）を指定してファイルを開くときの基準になります

詳しくは[作業ディレクトリ](#作業ディレクトリ)で説明します

### 6. ユーザー ID とグループ ID

プロセスを実行しているユーザーの情報です

ファイルのアクセス権限などに使われます

#### 実ユーザー ID（Real UID）と実効ユーザー ID（Effective UID）

プロセスには、実は複数のユーザー ID があります

- <strong>実ユーザー ID（Real UID）</strong>
  - プロセスを起動した実際のユーザーの ID です
  - `getuid()` で取得できます
- <strong>実効ユーザー ID（Effective UID / EUID）</strong>
  - 権限チェックに使われる ID です
  - 通常は実ユーザー ID と同じですが、特別なプログラムでは異なる場合があります
  - `geteuid()` で取得できます

同様に、グループ ID にも「実グループ ID」と「実効グループ ID（EGID）」があります

#### EUID が異なる例：setuid プログラム

`/usr/bin/passwd` コマンドは「setuid プログラム」の代表例です

<strong>setuid プログラム</strong>とは、実行ファイルに特殊な権限ビットが設定されており、誰が実行しても特定のユーザー（多くの場合 root）の権限で動作するプログラムです

この場合、実ユーザー ID は実行した本人のままですが、実効ユーザー ID はファイルの所有者（root）になります

これにより、一般ユーザーでも `/etc/shadow`（パスワードが保存されているファイル）に書き込むことができます

他の setuid プログラムの例

- `/usr/bin/ping` - ネットワークの raw ソケットを使うために root 権限が必要です

※ `sudo` コマンドで起動したプログラムは、通常は実ユーザー ID も実効ユーザー ID も両方 root（0）になります

これは setuid とは異なる仕組みです

---

## プロセス ID（PID）とは

### 基本的な説明

<strong>PID（Process ID）</strong>は、OS がすべてのプロセスに割り当てる一意の番号です

Linux の公式マニュアル（man ページ）には、こう書かれています

> getpid() returns the process ID (PID) of the calling process.

> getpid() は、呼び出したプロセスのプロセス ID を返します

### なぜ PID が必要なのか

複数のプロセスが動いているとき、OS は「どのプロセスの話をしているのか」区別する必要があります

例えば

- 「あのプロセスを止めたい」→ どのプロセス？
- 「あのプロセスにメモリを割り当てたい」→ どのプロセス？

### もし PID がなかったら？

<strong>プログラム名で識別する場合</strong>

同じプログラムを 2 つ起動したらどうなるでしょうか

`bash` を 2 つ起動したとき、「片方だけ終了したい」と言えません

<strong>メモリアドレスで識別する場合</strong>

プロセスがメモリ上で移動したり、再起動したりするとアドレスが変わります

安定した識別ができません

<strong>起動時刻で識別する場合</strong>

同時に複数のプロセスが起動することがあります

正確な時刻の管理も複雑です

### なぜ「番号」なのか

UNIX が初期に設計されたとき、マルチタスク（複数のプログラムを同時に動かす）のために、各プロセスを一意に識別する必要がありました

<strong>番号</strong>という単純な方式が選ばれた理由

- 整数なので比較が高速
- 配列のインデックスとして直接使える（O(1) でアクセス可能）
- 人間にも分かりやすい

PID があることで、OS は特定のプロセスを確実に識別できます

### PID の特徴

- <strong>一意である</strong>
  - 同時に2つのプロセスが同じ PID を持つことはない
- <strong>再利用される</strong>
  - プロセスが終了すると、その PID は後で別のプロセスに使われる可能性がある
- <strong>PID 1 は特別</strong>
  - Linux では、最初に起動するプロセス（init または systemd）は必ず PID 1

### PPID（親プロセス ID）

すべてのプロセスには「親」がいます

<strong>PPID（Parent Process ID）</strong>は、そのプロセスを生んだ親プロセスの PID です

Linux の公式マニュアルには

> getppid() returns the process ID of the parent of the calling process.

> getppid() は、呼び出したプロセスの親のプロセス ID を返します

---

## プロセスの親子関係

先ほど PPID（親プロセス ID）について触れました

ここでは、なぜすべてのプロセスに「親」がいるのか、もう少し詳しく見ていきます

### すべてのプロセスには親がいる

Linux では、すべてのプロセスは「誰かから生まれた」ものです

唯一の例外は PID 1（init または systemd）で、これは OS が直接起動します

### どうやってプロセスが生まれるか

プロセスは `fork()` という<strong>システムコール</strong>（プログラムが OS に「これをやって」とお願いする命令）で生まれます

Linux の公式マニュアルには

> fork() creates a new process by duplicating the calling process.

> fork() は、呼び出したプロセスを複製することで新しいプロセスを作成します

つまり、プロセスは「自分のコピー」を作ることで増えます

fork() の詳しい使い方は [02-fork-exec](./02-fork-exec.md) で学びます

### 親子関係の例

ターミナルで `ls` コマンドを実行する場合

1. ターミナル（bashなど）が動いている（これが親）
2. `ls` と入力して Enter を押す
3. bash が `fork()` で自分のコピーを作る（これが子）
4. 子プロセスが `exec()`（自分自身を別のプログラムに置き換える命令）で自分を `ls` プログラムに置き換える
5. `ls` が実行され、結果を表示して終了
6. bash に制御が戻る

### 親が先に死んだ場合

親プロセスが先に終了すると、子プロセスは「孤児（orphan）」になります

この場合、子プロセスは通常 PID 1（init または systemd）に引き取られます

ただし、Linux 3.4 以降では「subreaper」という仕組みがあります

祖先プロセスが `prctl(PR_SET_CHILD_SUBREAPER)` で subreaper として設定されている場合は、PID 1 ではなくその subreaper に引き取られます

systemd などのサービスマネージャがこの仕組みを使用しています

---

## プロセスの状態

プロセスは、常に同じ状態ではありません

### なぜ複数の状態が必要なのか

<strong>もし「実行中」と「終了」だけだったら？</strong>

キーボード入力を待っているプロセスも CPU を使い続けることになります

これでは CPU が無駄になり、他のプロセスが動けません

<strong>状態を分けることで解決する問題</strong>

| 状態     | 解決する問題                                               |
| -------- | ---------------------------------------------------------- |
| Running  | プロセスが実際に CPU を使っていることを示す                |
| Sleeping | 入力待ちなどのプロセスが CPU を消費しないようにする        |
| Stopped  | デバッグや一時停止のため、プロセスを保持しつつ実行を止める |
| Zombie   | 親プロセスが終了状態を確認するまで、終了コードを保持する   |

各状態があることで、OS は CPU を効率的に割り当てられます

### 主な状態

| 状態               | 英語                  | 記号 | 説明                                                    |
| ------------------ | --------------------- | ---- | ------------------------------------------------------- |
| 実行中/実行可能    | Running/Runnable      | R    | CPU で命令を実行中、または実行待ち                      |
| 待機中             | Sleeping              | S    | 何かを待っている（入力待ちなど）、シグナルで中断可能    |
| 待機中（割込不可） | Uninterruptible Sleep | D    | シグナルで中断できない待機状態（主にディスク I/O 待ち） |
| 停止中             | Stopped               | T    | 一時停止している                                        |
| ゾンビ             | Zombie                | Z    | 終了したが、親がまだ回収していない                      |
| アイドル           | Idle                  | I    | OS 内部の特別なプロセスが休止中                         |

### Running（実行中/実行可能）

CPU を使って実際にコードを実行している状態です

実際には「実行可能」という意味も含み、CPU の順番を待っている状態も含まれます

### Sleeping（待機中）

何かのイベントを待っている状態です

例えば

- キーボードからの入力を待っている
- ファイルの読み込みを待っている
- ネットワークからのデータを待っている

ほとんどのプロセスは、この状態で過ごしています

この状態は「Interruptible Sleep（割り込み可能な待機）」とも呼ばれ、シグナルを受け取ると待機を中断できます

### Uninterruptible Sleep（待機中・割込不可）

ディスク I/O などの完了を待っている状態です

この状態の特徴

- <strong>シグナルで中断できない</strong>のが最大の特徴です
- プログラムを強制終了するコマンド（`kill -9`）でも中断できません
- 通常は非常に短時間で終わります
- 長時間この状態が続く場合は、ハードウェアやドライバ（ハードウェアを制御するソフトウェア）に問題がある可能性があります

なぜ中断できないのか？

- ディスク I/O の途中で中断すると、データが破損する可能性があるためです
- カーネルは処理の整合性を保つために、完了するまで待つ必要があります

<strong>kill -9</strong> は、プロセスに「強制終了シグナル（SIGKILL）」を送るコマンドです

通常のプロセスはこのシグナルで強制終了しますが、Uninterruptible Sleep 状態のプロセスは例外です

シグナルについては [03-signal](./03-signal.md) で詳しく学びます

### Stopped（停止中）

一時停止している状態です

`Ctrl + Z`（キーボードの Ctrl キーと Z キーを同時に押す操作）を押すと、フォアグラウンド（画面に表示されて操作中）のプロセスがこの状態になります

### Zombie（ゾンビ）

プロセスの実行は終了したが、親プロセスがまだ終了を確認していない状態です

親が `wait()`（子プロセスの終了を待つ命令）で子の終了を確認すると、ゾンビは消えます

### Idle（アイドル）

OS 内部で動作する特別なプロセスが休止している状態です

一般のユーザープログラムではこの状態になることはありません

---

## プロセスを観察してみよう

実際にプロセスを見てみましょう

### ps コマンド

`ps` は、プロセスの一覧を表示するコマンドです

bash、zsh、fish などがシェルの例です

<strong>シェル</strong>とは、コマンドを受け付けて実行するプログラムです

<strong>ターミナル</strong>は、シェルを動かすための画面（ウィンドウ）です

ターミナルを開くと、その中でシェルが動きます

```bash
ps
```

<strong>すべてのプロセスを詳細表示</strong>

```bash
ps aux
```

### ps aux の出力の読み方

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 167892 11444 ?        Ss   09:00   0:01 /sbin/init
user      1234  0.1  0.5 412312 42000 pts/0    Ss   09:05   0:02 bash
```

<strong>各列の意味</strong>

※ <strong>仮想メモリ</strong>とは、OS がプロセスに見せかけているメモリ空間です

実際の物理メモリよりも大きな空間を使えるように見せかける仕組みです

<strong>物理メモリ</strong>は、実際にパソコンに搭載されているメモリ（RAM）です

| 列      | 説明                           |
| ------- | ------------------------------ |
| USER    | プロセスを実行しているユーザー |
| PID     | プロセス ID                    |
| %CPU    | CPU 使用率                     |
| %MEM    | メモリ使用率                   |
| VSZ     | 仮想メモリサイズ（キロバイト） |
| RSS     | 物理メモリ使用量（キロバイト） |
| TTY     | 接続しているターミナル         |
| STAT    | プロセスの状態                 |
| START   | 開始時刻                       |
| TIME    | CPU 使用時間                   |
| COMMAND | 実行しているコマンド           |

### pstree コマンド

プロセスの親子関係を木構造で表示します

```bash
pstree
```

出力例

```
systemd─┬─sshd───sshd───bash───pstree
        ├─cron
        └─rsyslogd
```

この出力に登場するプロセス名の意味は以下の通りです

- <strong>systemd</strong>：システム起動時に最初に動くプロセス（PID 1）
- <strong>sshd</strong>：SSH（Secure Shell：安全にリモートログインするためのプロトコル）のサーバープロセス
- <strong>bash</strong>：シェル（コマンドを受け付けて実行するプログラム）
- <strong>cron</strong>：定期実行を管理するプロセス
- <strong>rsyslogd</strong>：システムログを管理するプロセス

---

## /proc ファイルシステム

Linux には、プロセスの情報を見るための特別な場所があります

### /proc とは

`/proc` は<strong>疑似ファイルシステム</strong>と呼ばれます

#### 疑似ファイルシステムとは

通常のファイルシステムでは、ファイルはハードディスクや SSD などの<strong>ストレージ</strong>（記憶装置）に保存されています

しかし、疑似ファイルシステムは違います

<strong>疑似ファイルシステムの特徴</strong>

- ファイルはストレージ上に存在しない
- カーネル（OS の中核）がリアルタイムで情報を生成する
- 読み取るたびに最新の情報が返される
- 「ファイル」という形式でカーネルの情報にアクセスできる

つまり、<strong>ファイルの「ふり」をしているが、実際はカーネルへの窓口</strong>です

### なぜファイルシステムとして実装されているのか

専用のシステムコールを作る方法もありました

例えば `get_process_info(pid)` のような関数を OS に追加することもできたはずです

<strong>もし専用のシステムコールだったら？</strong>

- 新しい情報を追加するたびに、システムコールを追加・変更する必要がある
- プログラマーは新しい API を覚える必要がある
- 既存のツール（cat、grep など）は使えない

<strong>ファイルシステムとして実装した利点</strong>

Linux では「すべてはファイル」という UNIX 哲学を採用しています

この設計により

- `cat /proc/1234/status` でプロセス情報を表示できる
- `grep` で特定の情報を検索できる
- シェルスクリプトで簡単に処理できる
- 既存のツールがそのまま使える

新しい API を覚える必要がなく、既存の知識とツールがそのまま活用できます

Linux の公式マニュアルには

> The proc filesystem is a pseudo-filesystem which provides an interface to kernel data structures.

> proc ファイルシステムは、カーネルのデータ構造へのインターフェースを提供する疑似ファイルシステムです

「疑似」というのは、実際のファイルがディスク上にあるわけではなく、カーネルが「ファイルのふり」をして情報を見せているということです

### /proc/[pid] ディレクトリ

各プロセスには、`/proc/[PID]/` というディレクトリがあります

例えば、PID が 1234 のプロセスの情報は `/proc/1234/` にあります

### よく使うファイル

| ファイル            | 内容                               |
| ------------------- | ---------------------------------- |
| /proc/[pid]/cmdline | プロセスを起動したコマンドライン   |
| /proc/[pid]/status  | プロセスの状態（詳細）             |
| /proc/[pid]/fd/     | 開いているファイルディスクリプタ   |
| /proc/[pid]/maps    | メモリマップ                       |
| /proc/[pid]/environ | 環境変数                           |
| /proc/[pid]/cwd     | 作業ディレクトリへのリンク         |
| /proc/[pid]/exe     | 実行ファイルへのシンボリックリンク |
| /proc/[pid]/root    | ルートディレクトリへのリンク       |

<strong>シンボリックリンク</strong>とは、別のファイルやディレクトリを指し示す特殊なファイルです

Windows のショートカットや macOS のエイリアスに似ています

/proc/[pid]/exe は、そのプロセスが実行しているプログラムファイルを指し示しています

<strong>ルートディレクトリ</strong>とは、ファイルシステムの最上位（`/`）のことです

すべてのファイルとディレクトリは、ここから始まる階層構造に配置されています

### /proc/self

`/proc/self` は特別なリンクで、「自分自身のプロセス」を指します

自分の PID を知らなくても、`/proc/self/status` で自分の情報を見られます

---

## メモリの構造

プロセスには、OS から割り当てられた専用のメモリ空間があります

### なぜメモリを複数の領域に分けるのか

<strong>もし分けなかったら？</strong>

すべてのデータが 1 つの領域に混在していると

- プログラムのコード（命令）を誤って書き換えてしまう可能性がある
- 変数がどこに置かれているか予測できない
- メモリの効率的な管理ができない

<strong>分けることで得られる利点</strong>

- <strong>保護</strong>：コード領域を「読み取り専用」にして、誤った書き換えを防ぐ
- <strong>共有</strong>：同じプログラムを複数起動したとき、コード領域を共有できる（メモリ節約）
- <strong>効率</strong>：ヒープとスタックを柔軟に成長させられる

### メモリ領域の種類

プロセスのメモリは、大きく分けて以下の領域（セグメント）に分かれています

#### <strong>1. テキストセグメント（Text Segment）</strong>

プログラムのコード（命令）が置かれる場所です

読み取り専用で、実行中に変更されることはありません

#### <strong>2. データセグメント（Data Segment）</strong>

初期値を持つグローバル変数（プログラム全体で使える変数）が置かれる場所です

プログラムの開始時に、ファイルから読み込まれます

#### <strong>3. BSS セグメント（BSS Segment）</strong>

初期値を持たない（ゼロで初期化される）グローバル変数が置かれる場所です

「BSS」は「Block Started by Symbol」の略です

#### <strong>4. ヒープ（Heap）</strong>

`malloc()` などで動的に確保（プログラムの実行中に必要に応じて確保）されるメモリの場所です

プログラムの実行中に、必要に応じて拡大・縮小します

Linux の公式マニュアルには

> The malloc() function allocates size bytes and returns a pointer to the allocated memory.

> malloc() 関数は、指定されたバイト数を割り当て、割り当てられたメモリへのポインタ（メモリの場所を指し示す値）を返します

#### <strong>5. スタック（Stack）</strong>

ローカル変数（関数の中だけで使える変数）や関数呼び出しの情報が置かれる場所です

関数を呼び出すと増え、関数から戻ると減ります

### メモリ領域の配置

Linux では、メモリは以下のように低いアドレスから順に配置されます

| アドレス | 領域               | 成長方向             |
| -------- | ------------------ | -------------------- |
| 低       | テキストセグメント | （固定）             |
| ↓        | データセグメント   | （固定）             |
| ↓        | BSS セグメント     | （固定）             |
| ↓        | ヒープ             | ↓ 高いアドレスへ成長 |
| ↓        | （空き領域）       |                      |
| ↓        | スタック           | ↑ 低いアドレスへ成長 |
| 高       |                    |                      |

ヒープとスタックは互いに向かって成長します

#### なぜ逆方向に成長するのか

ヒープとスタックが逆方向に成長する理由は、<strong>メモリを効率よく使うため</strong>です

プログラムがどれだけヒープを使うか、どれだけスタックを使うかは、実行してみないとわかりません

もし両方が同じ方向に成長したらどうなるでしょうか？

<strong>同じ方向に成長した場合の問題</strong>

- ヒープ用に「最大これだけ」と領域を固定しなければならない
- スタック用にも「最大これだけ」と領域を固定しなければならない
- 片方が少なく、もう片方が多い場合、メモリが無駄になる

<strong>逆方向に成長する利点</strong>

- 間の空き領域を両方で共有できる
- ヒープをたくさん使うプログラムは、ヒープ側を多く使う
- スタックをたくさん使うプログラム（深い再帰など）は、スタック側を多く使う
- 柔軟にメモリを活用できる

※ <strong>再帰</strong>とは、関数が自分自身を呼び出すプログラミング技法です

関数を呼び出すたびにスタックが使われるため、深い再帰（何度も自分を呼び出す）はスタックを多く消費します

この設計のおかげで、ヒープとスタックが「衝突」しない限り、両方が自由にメモリを使えます

---

## 環境変数

### 環境変数とは

<strong>環境変数</strong>は、プロセスに渡される「名前=値」の形式の設定情報です

Linux の公式マニュアルには

> The variable environ points to an array of pointers to strings called the "environment".

> 変数 environ は、「環境」と呼ばれる文字列へのポインタの配列を指します

### なぜコマンドライン引数ではなく環境変数を使うのか

設定情報を渡す方法として、コマンドライン引数（`./program --config=value`）もあります

では、なぜ環境変数が別途存在するのでしょうか

<strong>コマンドライン引数の問題</strong>

- <strong>長さに制限がある</strong>：コマンドラインには最大長があります（Linux では通常 2MB 程度）
- <strong>毎回指定が必要</strong>：同じ設定を何度も書く必要がある
- <strong>秘密情報が見える</strong>：`ps` コマンドで他のユーザーに見られる可能性がある

<strong>環境変数の利点</strong>

- <strong>子プロセスに自動継承される</strong>：一度設定すれば、そこから起動したすべてのプロセスに引き継がれる
- <strong>多くのプログラムで共有できる</strong>：PATH や LANG など、複数のプログラムが参照する設定に便利
- <strong>プログラムのコードを変えずに動作を変更できる</strong>：DEBUG=1 などで動作を切り替えられる

### よく使う環境変数

| 変数名 | 説明                     |
| ------ | ------------------------ |
| PATH   | コマンドを探す場所の一覧 |
| HOME   | ホームディレクトリ       |
| USER   | ユーザー名               |
| SHELL  | 使用しているシェル       |
| PWD    | 現在の作業ディレクトリ   |
| LANG   | 言語設定                 |

### 環境変数の確認方法

<strong>すべての環境変数を表示</strong>

```bash
env
```

<strong>特定の環境変数を表示</strong>

```bash
echo $HOME
```

### 環境変数の継承

子プロセスは、親プロセスの環境変数を引き継ぎます

ただし、子プロセスが環境変数を変更しても、親には影響しません

---

## 作業ディレクトリ

### 作業ディレクトリとは

<strong>作業ディレクトリ（Current Working Directory）</strong>は、プロセスが「今いる場所」です

今いる場所からの位置（`./file.txt`など）でファイルを指定したとき、作業ディレクトリを基準にファイルが探されます

Linux の公式マニュアルには

> getcwd() copies an absolute pathname of the current working directory.

> getcwd() は、現在の作業ディレクトリのルートからの完全な場所をコピーします

### 作業ディレクトリの確認

```bash
pwd
```

### 作業ディレクトリの変更

```bash
cd /path/to/directory
```

---

## 用語集

| 用語                   | 英語                 | 説明                                                       |
| ---------------------- | -------------------- | ---------------------------------------------------------- |
| プロセス               | Process              | 実行中のプログラム                                         |
| プログラム             | Program              | ディスク上の実行ファイル                                   |
| プロセス ID            | Process ID / PID     | プロセスを識別する番号                                     |
| 一意                   | Unique               | 他と重複しない唯一の値                                     |
| 親プロセス             | Parent Process       | あるプロセスを生んだプロセス                               |
| 子プロセス             | Child Process        | あるプロセスから生まれたプロセス                           |
| 孤児プロセス           | Orphan Process       | 親プロセスが先に終了したプロセス（PID 1 等に引き取られる） |
| ゾンビプロセス         | Zombie Process       | 終了したが、親が wait() していないプロセス                 |
| デーモン               | Daemon               | バックグラウンドで動作するサービス用プロセス               |
| フォアグラウンド       | Foreground           | ターミナルと対話中のプロセス                               |
| バックグラウンド       | Background           | ターミナルから切り離されて動作するプロセス                 |
| システムコール         | System Call          | OS の機能を呼び出す仕組み                                  |
| シグナル               | Signal               | プロセスに送る通知（割り込みや終了要求など）               |
| ファイルディスクリプタ | File Descriptor      | 開いているファイルを識別する番号                           |
| パイプ                 | Pipe                 | プロセス間でデータをやり取りする仕組み                     |
| 環境変数               | Environment Variable | プロセスに渡される設定情報                                 |
| 作業ディレクトリ       | Working Directory    | プロセスが「今いる場所」                                   |
| ルートディレクトリ     | Root Directory       | ファイルシステムの最上位（/）                              |
| シンボリックリンク     | Symbolic Link        | 別のファイルやディレクトリを指し示す特殊なファイル         |
| 仮想メモリ             | Virtual Memory       | OS がプロセスに見せかけているメモリ空間                    |
| 物理メモリ             | Physical Memory      | 実際にパソコンに搭載されているメモリ（RAM）                |
| ヒープ                 | Heap                 | 動的に確保されるメモリ領域                                 |
| スタック               | Stack                | ローカル変数が置かれるメモリ領域                           |
| 再帰                   | Recursion            | 関数が自分自身を呼び出すプログラミング技法                 |
| I/O                    | Input/Output         | データの入力と出力                                         |
| プロセステーブル       | Process Table        | カーネルが管理するプロセス一覧                             |
| コンテキストスイッチ   | Context Switch       | CPU が実行するプロセスを切り替えること                     |
| ドライバ               | Driver               | ハードウェアを制御するソフトウェア                         |
| シェル                 | Shell                | コマンドを受け付けて実行するプログラム（bash、zsh など）   |
| ターミナル             | Terminal             | シェルを動かすための画面（ウィンドウ）                     |
| SSH                    | Secure Shell         | 安全にリモートログインするためのプロトコル                 |
| setuid                 | Set User ID          | 実行時に特定ユーザーの権限で動作する仕組み                 |
| subreaper              | Subreaper            | 孤児プロセスを引き取る役割を持つプロセス                   |

---

## 参考資料

このページの内容は、以下のソースに基づいています

- [getpid(2) - Linux manual page](https://man7.org/linux/man-pages/man2/getpid.2.html)
  - PID と PPID の取得
- [fork(2) - Linux manual page](https://man7.org/linux/man-pages/man2/fork.2.html)
  - プロセスの生成
- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc ファイルシステム
- [malloc(3) - Linux manual page](https://man7.org/linux/man-pages/man3/malloc.3.html)
  - メモリの動的割り当て
- [environ(7) - Linux manual page](https://man7.org/linux/man-pages/man7/environ.7.html)
  - 環境変数
- [getcwd(2) - Linux manual page](https://man7.org/linux/man-pages/man2/getcwd.2.html)
  - 作業ディレクトリ
- [prctl(2) - Linux manual page](https://man7.org/linux/man-pages/man2/prctl.2.html)
  - PR_SET_CHILD_SUBREAPER（subreaper の設定）

---

## 次のステップ

このトピックでは、「プロセスとは何か」を観察を通じて学びました

次の [02-fork-exec](./02-fork-exec.md) では、実際にプロセスを作る方法を学びます

- なぜすべてのプロセスに「親」がいるのか
- 新しいプログラムはどのように起動されるのか
- シェルがコマンドを実行する仕組み

これらの疑問に答えます
