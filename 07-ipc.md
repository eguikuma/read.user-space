<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 07-ipc：プロセス間通信

プロセス同士が<strong>データをやり取りする仕組み</strong>を学びます

---

## はじめに

前のトピック（[06-stdio](./06-stdio.md)）では、標準入出力ライブラリを学びました

- FILE 構造体と fd（ファイルディスクリプタ）の関係
- printf()、fopen() などの便利な関数
- バッファリングの仕組みと制御

<strong>FILE 構造体</strong>とは、fd にバッファやエラー情報を追加した、より使いやすい形式のことです

詳しくは [06-stdio](./06-stdio.md) を参照してください

ここまでの学習は、すべて「1 つのプロセス内」でのデータの流れでした

では、<strong>別のプロセスにデータを渡したい</strong>ときはどうすればよいでしょうか？

[03-signal](./03-signal.md) で、シグナルは「プロセス間通信の限定的な形式」と説明しました

シグナルでは「通知」は送れますが、「データ」は送れません

このトピックでは、<strong>プロセス間でデータをやり取りする方法</strong>を学びます

これを<strong>IPC（Inter-Process Communication：プロセス間通信）</strong>といいます

---

## 日常の例え

プロセス間通信を「家族間の連絡」に例えてみましょう

<strong>シグナル（03-signal）</strong>

インターホンのようなものです

「誰かが来た」ことはわかりますが、誰が何の用件で来たかはわかりません

<strong>パイプ</strong>

家の中にある「壁に開けた穴」のようなものです

同じ家（同じプロセスから fork した親子）に住む人同士なら、穴越しに声（データ）を直接伝えられます

パイプは fork() で作った親子プロセス間でのみ使えます

<strong>名前付きパイプ（FIFO）</strong>

家と家をつなぐ「糸電話」のようなものです

電話線（ファイル名）があれば、隣の家の人（別のプログラム）とも話せます

<strong>共有メモリ</strong>

共有の「掲示板」のようなものです

みんなが同じ掲示板を見て、書き込みを確認できます

ただし、同時に書き込もうとすると内容が混ざることがあります

データをコピーする必要がないので、非常に高速です

<strong>UNIX ドメインソケット</strong>

家の中の「内線電話」のようなものです

電話をかけて（connect）、相手が出たら（accept）、会話（send/recv）できます

<strong>クライアント/サーバーモデル</strong>で通信します

クライアント/サーバーモデルとは、「サービスを提供する側（サーバー）」と「サービスを利用する側（クライアント）」に役割を分ける通信方式のことです

サーバーは待ち受け（accept）し、クライアントが接続（connect）してきたら通信を開始します

---

## このページで学ぶこと

このトピックでは、以下のシステムコールと関数を学びます

<strong>パイプ関連</strong>

- <strong>pipe()</strong>
  - パイプを作成する
- <strong>dup2()</strong>
  - ファイルディスクリプタを複製する（05-file-descriptor の復習）

<strong>名前付きパイプ（FIFO）関連</strong>

- <strong>mkfifo()</strong>
  - 名前付きパイプを作成する
- <strong>unlink()</strong>
  - ファイルを削除する

<strong>共有メモリ関連</strong>

- <strong>shm_open()</strong>
  - 共有メモリオブジェクトを作成・開く
- <strong>ftruncate()</strong>
  - サイズを設定する
- <strong>mmap()</strong>
  - メモリにマッピングする
- <strong>munmap()</strong>
  - マッピングを解除する
- <strong>shm_unlink()</strong>
  - 共有メモリオブジェクトを削除する

<strong>UNIX ドメインソケット関連</strong>

- <strong>socket()</strong>
  - ソケットを作成する
- <strong>bind()</strong>
  - ソケットにアドレスを割り当てる
- <strong>listen()</strong>
  - 接続を待ち受ける
- <strong>accept()</strong>
  - 接続を受け入れる
- <strong>connect()</strong>
  - サーバーに接続する
- <strong>send() / recv()</strong>
  - データを送受信する

---

## 目次

1. [プロセス間通信とは何か](#プロセス間通信とは何か)
2. [IPC の種類と比較](#ipc-の種類と比較)
3. [パイプとは](#パイプとは)
4. [pipe() システムコール](#pipe-システムコール)
5. [親子プロセス間でのパイプ通信](#親子プロセス間でのパイプ通信)
6. [dup2() によるパイプとコマンドの連携](#dup2-によるパイプとコマンドの連携)
7. [名前付きパイプ（FIFO）](#名前付きパイプfifo)
8. [共有メモリの基礎](#共有メモリの基礎)
9. [UNIX ドメインソケットの基礎](#unix-ドメインソケットの基礎)
10. [IPC の選び方](#ipc-の選び方)
11. [まとめ：このリポジトリで学んだこと](#まとめこのリポジトリで学んだこと)
12. [用語集](#用語集)
13. [参考資料](#参考資料)

---

## プロセス間通信とは何か

<strong>プロセス間通信（IPC）</strong>とは、異なるプロセスがデータをやり取りする仕組みです

なぜ必要なのでしょうか？

[01-process](./01-process.md) で学んだように、各プロセスは独立したメモリ空間を持っています

あるプロセスが変数に値を書き込んでも、別のプロセスからはその値が見えません

これはセキュリティと安定性のために重要ですが、プロセス間でデータを共有したいときには障壁になります

そこで、OS は安全にデータをやり取りするための仕組みを提供しています

それが IPC です

---

## IPC の種類と比較

Linux には複数の IPC 方式があります

| 方式          | 方向   | 速度 | 血縁関係 | 用途                        |
| ------------- | ------ | ---- | -------- | --------------------------- |
| パイプ        | 一方向 | 中   | 必要     | 親子プロセス間の単純な通信  |
| FIFO          | 一方向 | 中   | 不要     | 無関係なプロセス間の通信    |
| 共有メモリ    | 双方向 | 高   | 不要     | 大量データの高速共有        |
| UNIX ソケット | 双方向 | 中   | 不要     | クライアント/サーバー型通信 |

### なぜ複数の IPC 方式があるのか

<strong>もし 1 つの IPC で全てをまかなおうとしたら？</strong>

| 要件             | 理想的な IPC    | 理由                         |
| ---------------- | --------------- | ---------------------------- |
| 単純な親子通信   | パイプ          | 設定が最小限、名前解決が不要 |
| 大量データ転送   | 共有メモリ      | コピーなしで最速             |
| 双方向通信       | ソケット        | 設計がシンプル               |
| 無関係なプロセス | FIFO / ソケット | 名前でアクセス可能           |

<strong>1 つの方式では、すべての要件を効率よく満たせません</strong>

共有メモリは最速ですが、同期処理が複雑です

パイプは単純ですが、双方向通信には 2 本必要です

ソケットは柔軟ですが、単純な用途にはオーバーヘッドがあります

<strong>血縁関係</strong>とは、fork() によって作られた親子関係のことです

パイプは fork() 前に作成し、fork() 後に親子で共有するため、血縁関係が必要です

FIFO、共有メモリ、ソケットは「名前」でアクセスするため、無関係なプロセス間でも使えます

---

## パイプとは

<strong>パイプ</strong>は、プロセス間でデータを流すための「管」のようなものです

### パイプの2つの端

パイプには2つの端があります

- <strong>書き込み端</strong>：データを送り込む側の入り口です
- <strong>読み取り端</strong>：データを取り出す側の出口です

書き込み端からデータを入れると、読み取り端から出てきます

シェルで使う `|` は、まさにこのパイプです

```bash
ls | wc -l
```

この例では、ls の出力がパイプを通じて wc に渡されます

ls は stdout に出力しているだけですが、シェルが stdout をパイプに接続しています

### なぜパイプは親子間限定なのか

パイプは fork() で作った親子プロセス間でしか使えません

これは設計上の制約ではなく、<strong>意図的なシンプルさ</strong>です

<strong>もしパイプに名前を付けて誰でもアクセスできるようにしたら？</strong>

- 名前の衝突を防ぐ仕組みが必要
- アクセス権限の管理が必要
- 名前解決のオーバーヘッドが発生

親子間限定にすることで、これらの複雑さを避けられます

| 特徴 | 親子間限定の利点                  |
| ---- | --------------------------------- |
| 識別 | fd 番号だけで済む（名前解決不要） |
| 権限 | 親子なので自動的に信頼関係がある  |
| 速度 | 設定が最小限で高速                |

「名前でアクセスしたい」場合は、FIFO（名前付きパイプ）やソケットを使います

用途に応じて仕組みを使い分けるのが UNIX の設計思想です

### パイプの特徴

- <strong>一方向（Unidirectional）</strong>
  - データは一方向にしか流れません
  - 双方向通信には 2 本のパイプが必要です

- <strong>ストリーム型</strong>
  - <strong>ストリーム</strong>とは、データを「流れ」として扱う方式のことです
  - <strong>バイト列</strong>（1バイトずつ並んだデータ）として連続的に流れます
  - 「ここからここまでが1つのメッセージ」という区切り（<strong>メッセージの境界</strong>）はありません
  - 例えば「Hello」と「World」を続けて書き込むと、読み取り側では「HelloWorld」として届くことがあります

- <strong>バッファ付き</strong>
  - <strong>バッファ</strong>とは、データを一時的に溜めておく場所のことです
  - <strong>カーネル</strong>（OS の中核部分）がバッファを用意しています
  - 書き込み側と読み取り側の速度差を吸収します

### パイプのデータフロー

パイプを通じてデータがどのように流れるかを見てみましょう

最も典型的な使い方は、親子プロセス間での通信です

<strong>親子プロセス間でのパイプ</strong>

| 手順 | 親プロセス           | カーネル     | 子プロセス           |
| ---- | -------------------- | ------------ | -------------------- |
| 1    | pipe() でパイプ作成  | パイプ生成   |                      |
| 2    | fork() で子を生成    |              | 親のコピーとして誕生 |
| 3    | 書き込み端を close() |              | 読み取り端を close() |
| 4    |                      |              | write() でデータ送信 |
| 5    |                      | データを中継 |                      |
| 6    | read() でデータ受信  |              |                      |
| 7    | 読み取り端を close() | パイプ消滅   | 書き込み端を close() |

<strong>シェルのパイプ（ls | wc -l）の流れ</strong>

| 手順 | ls プロセス              | パイプ     | wc プロセス            |
| ---- | ------------------------ | ---------- | ---------------------- |
| 1    | stdout → パイプに接続    | 作成       | stdin ← パイプに接続   |
| 2    | printf() で出力          | データ蓄積 |                        |
| 3    |                          | データ中継 | read() で読み取り      |
| 4    | 終了（write 端が閉じる） | EOF 発生   | EOF を検知して処理完了 |

ls は自分の出力先がパイプであることを知りません

wc も自分の入力元がパイプであることを知りません

これがシェルの<strong>「透過的なリダイレクト」</strong>の仕組みです

<strong>リダイレクト</strong>とは、入出力先を変更することです

<strong>透過的</strong>とは、プログラムが変更を意識しなくても動作するという意味です

つまり、プログラムは何も変えずに、シェルが裏側で入出力先をパイプに切り替えているのです

<strong>バッファリングとの関係</strong>

[06-stdio](./06-stdio.md) で学んだバッファリングは、パイプ通信でも重要です

printf() は内部でバッファリングを行うため、パイプに書き込んだデータがすぐに相手に届かないことがあります

特に、パイプに接続された printf() は<strong>フルバッファリング</strong>になります

<strong>フルバッファリング</strong>とは、バッファが満杯になるまでデータを溜める方式です

そのため、バッファが満杯になるまでデータが送信されません

リアルタイムな通信が必要な場合は、以下のいずれかを使用します

- fflush(stdout) でバッファを強制的に送信する
- setlinebuf(stdout) で<strong>行バッファリング</strong>（改行が来るまでデータを溜める方式）に切り替える
- write() を直接使用する（バッファリングなし）

バッファリングの詳細は [06-stdio](./06-stdio.md) で学びました

---

## pipe() システムコール

<strong>システムコール</strong>とは、プログラムが OS に処理を依頼する仕組みのことです

詳しくは [01-process](./01-process.md) を参照してください

<strong>pipe()</strong> は、パイプを作成するシステムコールです

```c
#include <unistd.h>

int pipefd[2];
int result = pipe(pipefd);
```

pipe() は 2 つのファイルディスクリプタを作成します

| 変数      | 説明          |
| --------- | ------------- |
| pipefd[0] | 読み取り用 fd |
| pipefd[1] | 書き込み用 fd |

<strong>覚え方</strong>：0 は標準入力（STDIN_FILENO = 0）、1 は標準出力（STDOUT_FILENO = 1）に対応しています

「入力＝読み取り」「出力＝書き込み」と考えると覚えやすいでしょう

pipefd[1] に write() したデータは、pipefd[0] から read() できます

戻り値は成功時に 0、失敗時に -1 です

パイプと fd の関係を思い出してください

[05-file-descriptor](./05-file-descriptor.md) で学んだように、fd はファイルだけでなく、パイプやソケットなど様々なリソースを表します

パイプへの読み書きは、ファイルと同じ read()、write()、close() で行えます

---

## 親子プロセス間でのパイプ通信

パイプの典型的な使い方は、fork() と組み合わせることです

1. pipe() でパイプを作成
2. fork() でプロセスを複製
3. 親子それぞれで不要な端を close()
4. 一方が write()、もう一方が read()

```c
int pipefd[2];
pipe(pipefd);

pid_t pid = fork();

if (pid == 0) {
    /* 子プロセス：書き込み側 */
    close(pipefd[0]);  /* 読み取り端を閉じる */
    write(pipefd[1], "Hello", 6);
    close(pipefd[1]);
} else {
    /* 親プロセス：読み取り側 */
    close(pipefd[1]);  /* 書き込み端を閉じる */
    char buf[256];
    read(pipefd[0], buf, sizeof(buf));
    close(pipefd[0]);
}
```

### fork() 後のファイルディスクリプタの状態

fork() を呼ぶと、子プロセスは親のファイルディスクリプタの<strong>コピー</strong>を持ちます

つまり、fork() 直後は以下の状態になります

| プロセス | pipefd[0]（読み取り端） | pipefd[1]（書き込み端） |
| -------- | ----------------------- | ----------------------- |
| 親       | 持っている              | 持っている              |
| 子       | 持っている              | 持っている              |

<strong>重要</strong>：親と子の fd は、<strong>同じパイプ</strong>を指しています

OS は「このパイプの書き込み端を開いている fd がいくつあるか」を数えています

これを<strong>参照カウント</strong>といいます

```
fork() 直後の参照カウント
─── 読み取り端：2（親 + 子）
─── 書き込み端：2（親 + 子）
```

### EOF が発生する条件

read() が EOF（データの終わり）を返すのは、<strong>書き込み端の参照カウントが 0 になったとき</strong>です

つまり、パイプに書き込む可能性のある fd が<strong>すべて閉じられたとき</strong>に、読み取り側は「もうデータは来ない」と判断できます

### 各 close() の役割

コード中の 4 つの close() には、それぞれ意味があります

```c
if (pid == 0) {
    /* 子プロセス：書き込み側 */
    close(pipefd[0]);  /* ① */
    write(pipefd[1], "Hello", 6);
    close(pipefd[1]);  /* ② */
} else {
    /* 親プロセス：読み取り側 */
    close(pipefd[1]);  /* ③ */
    char buf[256];
    read(pipefd[0], buf, sizeof(buf));
    close(pipefd[0]);  /* ④ */
}
```

| 番号 | 場所           | 何を閉じるか | 目的                                       |
| ---- | -------------- | ------------ | ------------------------------------------ |
| ①    | 子（書く前）   | 読み取り端   | 使わない fd を閉じてリソースを節約         |
| ②    | 子（書いた後） | 書き込み端   | 「書き込み完了」を親に伝える（EOF の合図） |
| ③    | 親（読む前）   | 書き込み端   | EOF を検知可能にする（後述）               |
| ④    | 親（読んだ後） | 読み取り端   | 使い終わった fd を閉じてリソースを解放     |

### なぜ ③ が必要なのか（最も重要）

③ を忘れると、<strong>親プロセスは永遠に待ち続けます</strong>

その理由を参照カウントで追ってみましょう

<strong>③ を実行した場合（正常）</strong>

```
1. fork() 直後
   ─── 書き込み端の参照カウント：2（親 + 子）

2. 親が close(pipefd[1]) を実行【③】
   ─── 書き込み端の参照カウント：1（子のみ）

3. 子が write() してデータを送る

4. 子が close(pipefd[1]) を実行【②】
   ─── 書き込み端の参照カウント：0 ← EOF 発生！

5. 親の read() が EOF を検知して終了
```

<strong>③ を忘れた場合（デッドロック）</strong>

```
1. fork() 直後
   ─── 書き込み端の参照カウント：2（親 + 子）

2. 親が close(pipefd[1]) を実行しない
   ─── 書き込み端の参照カウント：2（親 + 子）のまま

3. 子が write() してデータを送る

4. 子が close(pipefd[1]) を実行【②】
   ─── 書き込み端の参照カウント：1（親がまだ持っている）

5. 親の read() は EOF を待ち続ける
   ─── 「書き込み端がまだ開いている（自分自身の！）」と判断
   ─── 永遠にブロック
```

親自身が書き込み端を持っていると、「自分がまだ書くかもしれない」と OS に判断され、EOF が発生しません

### リソースの解放

もう一つの理由は<strong>リソースの解放</strong>です

<strong>リソース</strong>とは、プログラムが使用するメモリやファイルなどのシステム資源のことです

- 使わない fd を開いたままにするのは無駄です
- fd の数には上限があるため、不要な fd は閉じるべきです

---

## dup2() によるパイプとコマンドの連携

シェルの `|` を再現するには、<strong>dup2()</strong> を使います

dup2() は [05-file-descriptor](./05-file-descriptor.md) で学んだ関数です

```c
int dup2(int oldfd, int newfd);
```

dup2(oldfd, newfd) は、oldfd を newfd にコピーします

これを使うと、stdout をパイプの書き込み端に「すり替える」ことができます

### 標準入出力の定数

以下の定数は `<unistd.h>` で定義されています

| 定数          | 値  | 意味       |
| ------------- | --- | ---------- |
| STDIN_FILENO  | 0   | 標準入力   |
| STDOUT_FILENO | 1   | 標準出力   |
| STDERR_FILENO | 2   | 標準エラー |

### execlp() とは

<strong>execlp()</strong> は、[02-fork-exec](./02-fork-exec.md) で学んだ exec() ファミリーの一つです

現在のプロセスを別のプログラムに置き換えます

「p」は PATH 環境変数から実行ファイルを探すことを意味します

### パイプとコマンドの連携例

シェルが `ls | wc -l` を実行するとき、内部では以下のような処理をしています

```c
/* 子プロセス 1（ls を実行） */
close(pipefd[0]);
dup2(pipefd[1], STDOUT_FILENO);  /* stdout をパイプに接続 */
close(pipefd[1]);
execlp("ls", "ls", NULL);

/* 子プロセス 2（wc -l を実行） */
close(pipefd[1]);
dup2(pipefd[0], STDIN_FILENO);   /* stdin をパイプに接続 */
close(pipefd[0]);
execlp("wc", "wc", "-l", NULL);
```

コードだけでは流れが掴みにくいので、各ステップで fd がどう変化するかを追ってみましょう

[05-file-descriptor](./05-file-descriptor.md) の「リダイレクトの仕組み」と同じ考え方です

<strong>子プロセス 1（ls 側）の fd 変化</strong>

fork() 直後、子プロセス 1 はパイプの両端を持っています

```
fd 0 → キーボード（標準入力）
fd 1 → 画面（標準出力）        ← ls はここに書く
fd 2 → 画面（標準エラー）
fd 3 → パイプの読み取り端       ← pipefd[0]
fd 4 → パイプの書き込み端       ← pipefd[1]
```

```c
close(pipefd[0]);  /* ls は読み取りしないので不要 */
```

```
fd 0 → キーボード
fd 1 → 画面                     ← まだ画面のまま
fd 2 → 画面
fd 4 → パイプの書き込み端
```

```c
dup2(pipefd[1], STDOUT_FILENO);  /* fd 1 をパイプの書き込み端にすり替える */
```

```
fd 0 → キーボード
fd 1 → パイプの書き込み端       ← すり替わった！
fd 2 → 画面
fd 4 → パイプの書き込み端       ← まだ残っている
```

```c
close(pipefd[1]);  /* fd 4 は用済み、fd 1 があれば十分 */
```

```
fd 0 → キーボード
fd 1 → パイプの書き込み端       ← ls はここに書く
fd 2 → 画面
```

```c
execlp("ls", "ls", NULL);  /* ls に置き換わる（fd はそのまま引き継がれる） */
```

ls は fd 1 に printf() するだけですが、fd 1 はパイプに繋がっているので、出力は自動的にパイプに流れます

<strong>子プロセス 2（wc 側）の fd 変化</strong>

同様に、fork() 直後の状態から始まります

```
fd 0 → キーボード（標準入力）   ← wc はここから読む
fd 1 → 画面（標準出力）
fd 2 → 画面（標準エラー）
fd 3 → パイプの読み取り端       ← pipefd[0]
fd 4 → パイプの書き込み端       ← pipefd[1]
```

```c
close(pipefd[1]);  /* wc は書き込みしないので不要 */
```

```c
dup2(pipefd[0], STDIN_FILENO);  /* fd 0 をパイプの読み取り端にすり替える */
```

```
fd 0 → パイプの読み取り端       ← すり替わった！
fd 1 → 画面
fd 2 → 画面
fd 3 → パイプの読み取り端       ← まだ残っている
```

```c
close(pipefd[0]);  /* fd 3 は用済み、fd 0 があれば十分 */
```

```c
execlp("wc", "wc", "-l", NULL);  /* wc に置き換わる */
```

wc は fd 0 から read() するだけですが、fd 0 はパイプに繋がっているので、ls の出力がパイプ経由で届きます

<strong>全体の流れ</strong>

```
ls が fd 1 に write() → パイプ → wc が fd 0 から read()
```

ls も wc も、パイプの存在を一切知りません

シェルが裏で fd のすり替えを行うことで、2つのコマンドが連携しています

これが `ls | wc -l` の仕組みです

---

## 名前付きパイプ（FIFO）

<strong>名前付きパイプ（FIFO）</strong>は、<strong>ファイルシステム</strong>上に存在するパイプです

<strong>ファイルシステム</strong>とは、OS がファイルを管理する仕組みのことです

「ファイルシステム上に存在する」とは、ls コマンドで見えるファイルとして作成されるという意味です

通常のパイプは fork() した親子間でしか使えませんが、FIFO は任意のプロセス間で使えます

### mkfifo() による作成

<strong>mkfifo()</strong> で FIFO を作成します

```c
#include <sys/stat.h>

mkfifo("/tmp/my_fifo", 0666);
```

### FIFO の使い方

作成後は通常のファイルと同様に open() で開けます

O_WRONLY は書き込み専用、O_RDONLY は読み取り専用でファイルを開くフラグです

これらのフラグは [05-file-descriptor](./05-file-descriptor.md) で学びました

```c
/* 書き込み側 */
int fd = open("/tmp/my_fifo", O_WRONLY);
write(fd, "Hello", 6);

/* 読み取り側（別のプロセス） */
int fd = open("/tmp/my_fifo", O_RDONLY);
read(fd, buf, sizeof(buf));
```

### FIFO の特徴

- ファイルシステム上に存在する（ls で見える）
- 血縁関係のないプロセス間で使える
- open() で<strong>ブロック</strong>する
- 不要になったら unlink() で削除する

### 「ブロック」とは

<strong>ブロック</strong>とは、ある条件が満たされるまで処理が進まず待機することです

FIFO の open() は、<strong>相手が open() するまで待機</strong>します

| 状況                    | 動作                             |
| ----------------------- | -------------------------------- |
| 読み取り側が先に open() | 書き込み側が open() するまで待機 |
| 書き込み側が先に open() | 読み取り側が open() するまで待機 |
| 両方が open()           | 両方とも処理が進む               |

### なぜブロックするのか

FIFO は「両端が揃ってはじめて通信できる」という設計になっています

片方しかいない状態では通信できないため、OS は「相手が準備できるまで待て」という動作にしています

### unlink() による削除

<strong>unlink()</strong> は、ファイルシステムからファイル名を削除する関数です

FIFO は使い終わったら unlink() で削除します

```c
unlink("/tmp/my_fifo");
```

---

## 共有メモリの基礎

<strong>共有メモリ</strong>は、複数のプロセスが同じメモリ領域を共有する仕組みです

パイプはデータを「コピー」して渡しますが、共有メモリは同じ場所を「参照」します

そのため、大量のデータを高速にやり取りできます

### POSIX 共有メモリとは

<strong>POSIX</strong>とは、UNIX 系 OS の標準仕様のことです

Portable Operating System Interface の略で、「ポジックス」と読みます

POSIX に準拠したプログラムは、Linux、macOS など異なる OS 間で移植しやすくなります

<strong>POSIX 共有メモリ</strong>は、この標準仕様に基づいた共有メモリの使い方です

### 共有メモリの使い方

1. <strong>shm_open()</strong> で共有メモリオブジェクトを作成
2. <strong>ftruncate()</strong> でサイズを設定
3. <strong>mmap()</strong> でメモリにマッピング
4. 通常のポインタとしてアクセス
5. <strong>munmap()</strong> でマッピングを解除
6. <strong>shm_unlink()</strong> で共有メモリを削除

### 用語の説明

<strong>共有メモリオブジェクト</strong>とは、OS が管理する共有メモリの実体のことです

Linux では /dev/shm/ ディレクトリに作成されます

<strong>マッピング</strong>とは、あるリソースをメモリ空間に対応付けることです

マッピング後は、通常のポインタと同じようにアクセスできます

<strong>ftruncate()</strong> は、ファイルやオブジェクトのサイズを設定する関数です

### フラグの説明

コード内で使用するフラグの意味は以下のとおりです

| フラグ     | 意味                         |
| ---------- | ---------------------------- |
| O_CREAT    | 存在しなければ作成する       |
| O_RDWR     | 読み書き両用で開く           |
| PROT_READ  | 読み取り可能                 |
| PROT_WRITE | 書き込み可能                 |
| MAP_SHARED | 変更を他のプロセスと共有する |

### コード例

```c
/* 共有メモリを作成 */
int fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0666);
ftruncate(fd, 4096);  /* 4096 バイトのサイズを設定 */

/* メモリにマッピング */
void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

/* 通常のポインタとしてアクセス */
/* strcpy() は文字列をコピーする標準ライブラリ関数です */
strcpy(ptr, "Hello");

/* クリーンアップ */
munmap(ptr, 4096);      /* マッピングを解除 */
shm_unlink("/my_shm");  /* 共有メモリを削除 */
```

### 共有メモリの注意点

<strong>なぜ共有メモリは別途同期が必要なのか</strong>

パイプや FIFO では、OS が自動的にデータの受け渡しを調整します

書き込みと読み取りは別々の操作で、カーネルがバッファを管理するからです

<strong>共有メモリではなぜ自動調整がないのか？</strong>

共有メモリは「同じメモリ領域を直接参照する」仕組みです

カーネルは「誰が読んでいるか」「誰が書いているか」を関知しません

```
パイプの場合：
  プロセスA → write() → [カーネルバッファ] → read() → プロセスB
                         ↑ カーネルが調整

共有メモリの場合：
  プロセスA → 直接アクセス → [共有領域] ← 直接アクセス ← プロセスB
                             ↑ 誰も調整しない
```

そのため、複数プロセスが同時にアクセスすると<strong>競合</strong>が発生します

<strong>競合</strong>とは、複数のプロセスが同時に同じデータにアクセスし、予期しない結果になることです

例えば、2つのプロセスが同時に同じ変数に「+1」しようとすると、1回分しか増えないことがあります

この問題を防ぐには、<strong>セマフォ</strong>や<strong>ミューテックス</strong>という「順番待ち」の仕組みを使います

| 用語           | 意味                                                |
| -------------- | --------------------------------------------------- |
| セマフォ       | 同時にアクセスできる数を制限する仕組み              |
| ミューテックス | 1つだけがアクセスできるようにする仕組み（相互排他） |

これらの詳細は並行プログラミングの範囲となるため、このトピックでは扱いません

共有メモリを使う場合は、「同時アクセスの問題がある」ことを覚えておいてください

---

## UNIX ドメインソケットの基礎

### ソケットとは

<strong>ソケット</strong>とは、プロセス間やコンピュータ間でデータを送受信するための「接続口」のことです

電気のコンセント（英語で socket）に差し込んで電気を使うように、ソケットに接続してデータをやり取りします

### ネットワークソケットとの違い

インターネットでは<strong>ネットワークソケット</strong>が使われます

<strong>TCP/IP</strong>は、インターネットで使われる通信規約（プロトコル）です

| 項目     | ネットワークソケット     | UNIX ドメインソケット |
| -------- | ------------------------ | --------------------- |
| 通信範囲 | インターネット全体       | 同じコンピュータ内    |
| 識別方法 | IP アドレス + ポート番号 | ファイルパス          |
| 速度     | やや遅い                 | 高速                  |

<strong>UNIX ドメインソケット</strong>は、同じマシン上のプロセス間で通信するソケットです

ネットワークを経由しないため、高速で安全です

### なぜ同じマシン内でも速度差があるのか

同じマシン上でネットワークソケット（TCP/IP）を使うこともできます

では、なぜ UNIX ドメインソケットの方が高速なのでしょうか

<strong>TCP/IP を使うと発生するオーバーヘッド</strong>

| 処理             | ネットワークソケット     | UNIX ドメインソケット |
| ---------------- | ------------------------ | --------------------- |
| アドレス解決     | IP アドレス + ポート番号 | ファイルパスのみ      |
| プロトコル処理   | TCP/IP スタック全体      | なし                  |
| チェックサム計算 | 毎パケット必要           | 不要                  |
| ルーティング判断 | ループバックでも経由     | なし                  |

<strong>UNIX ドメインソケット固有の機能</strong>

UNIX ドメインソケットには、ネットワークソケットにはない機能もあります

- <strong>ファイルディスクリプタの受け渡し</strong>
  - 開いているファイルやソケットを別プロセスに渡せる
  - ネットワーク越しでは不可能

- <strong>認証情報の取得</strong>
  - 接続相手の UID/GID を確認できる
  - ネットワークでは別途認証が必要

同じマシン上での通信なら、UNIX ドメインソケットを選ぶのが合理的です

### API について

<strong>API</strong>（Application Programming Interface）とは、プログラムが使う関数や仕組みの集まりのことです

UNIX ドメインソケットは、ネットワークソケット（TCP/IP）と似た API を使います

そのため、ここで学んだ知識は、ネットワークプログラミングにそのまま応用できます

### クライアント/サーバーモデル

UNIX ドメインソケットは<strong>クライアント/サーバーモデル</strong>で通信します

<strong>サーバー</strong>は、サービスを提供する側です

<strong>クライアント</strong>は、サービスを利用する側です

<strong>サーバー側の流れ</strong>

1. socket() でソケットを作成
2. bind() でアドレス（ファイルパス）を割り当て
3. listen() で接続を待ち受け
4. accept() で接続を受け入れ
5. recv() / send() でデータをやり取り
6. close() でソケットを閉じる

<strong>クライアント側の流れ</strong>

1. socket() でソケットを作成
2. connect() でサーバーに接続
3. send() / recv() でデータをやり取り
4. close() でソケットを閉じる

### ストリーム型とデータグラム型

UNIX ドメインソケットには 2 つの種類があります

| 種類           | 定数        | 特徴                                         |
| -------------- | ----------- | -------------------------------------------- |
| ストリーム型   | SOCK_STREAM | 接続を確立してから通信する（電話のイメージ） |
| データグラム型 | SOCK_DGRAM  | 接続なしでメッセージを送る（郵便のイメージ） |

<strong>ストリーム型（SOCK_STREAM）</strong>

- 接続を確立してから通信する
- データの順序が保証される
- データの欠落がない

<strong>データグラム型（SOCK_DGRAM）</strong>

- <strong>データグラム</strong>とは、独立したメッセージの単位のことです
- 接続なしでメッセージを送る
- メッセージの境界が保持される
- UNIX ドメインソケットでは信頼性があり、順序も保証される

<strong>補足</strong>：ネットワーク上の UDP（User Datagram Protocol）では、データの消失や順序逆転が発生する可能性がありますが、UNIX ドメインソケットの SOCK_DGRAM はカーネル内で完結するため、常に信頼性があり、データグラムの順序が入れ替わることもありません

このトピックでは、より一般的なストリーム型を使用します

### UNIX ドメインソケットの特徴まとめ

- ファイルシステム上のパス名（例：/tmp/my_socket）で識別される
- 双方向通信が可能
- ネットワークプログラミングへの橋渡しになる

---

## IPC の選び方

どの IPC を使うべきかは、要件によって異なります

<strong>親子プロセス間の単純な通信</strong>

→ パイプ（pipe）

最もシンプルで、fork() と組み合わせるだけで使えます

<strong>無関係なプロセス間の通信</strong>

→ FIFO または UNIX ドメインソケット

FIFO は一方向、ソケットは双方向です

<strong>大量のデータを高速に共有</strong>

→ 共有メモリ

データのコピーが発生しないため最速ですが、同期処理が必要です

<strong>クライアント/サーバー型の通信</strong>

→ UNIX ドメインソケット

将来的にネットワーク越しに拡張できます

---

## まとめ：このリポジトリで学んだこと

このリポジトリでは、「ユーザー空間からプロセスがどう動くか」を学びました

### 学んだトピック

| トピック           | 内容                 |
| ------------------ | -------------------- |
| 01-process         | プロセスとは何か     |
| 02-fork-exec       | プロセスを作る       |
| 03-signal          | プロセスに通知する   |
| 04-thread          | プロセス内で並行処理 |
| 05-file-descriptor | OS のファイル管理    |
| 06-stdio           | 標準入出力ライブラリ |
| 07-ipc             | プロセス間通信       |

### 全体像

```
┌─────────────────────────────────────────┐
│           ユーザーのプログラム            │
├─────────────────────────────────────────┤
│            ユーザー空間の API             │
│  ・プロセス管理 (01, 02)                 │
│  ・シグナル (03)                         │
│  ・スレッド (04)                         │
│  ・ファイルディスクリプタ (05)            │
│  ・標準入出力 (06)                       │
│  ・プロセス間通信 (07)                   │
├─────────────────────────────────────────┤
│           libc / システムコール           │
├─────────────────────────────────────────┤
│              OS（カーネル）               │
├─────────────────────────────────────────┤
│             ハードウェア                  │
└─────────────────────────────────────────┘
```

ユーザー空間でプログラムがどう動くかを理解していれば、その下で動くカーネルの仕組みも理解しやすくなります

---

## 用語集

| 用語                  | 説明                                                             |
| --------------------- | ---------------------------------------------------------------- |
| IPC                   | Inter-Process Communication（プロセス間通信）の略                |
| パイプ                | プロセス間でデータを流す一方向の管                               |
| 書き込み端            | パイプの書き込み用 fd（pipefd[1]）のこと                         |
| 読み取り端            | パイプの読み取り用 fd（pipefd[0]）のこと                         |
| FIFO                  | 名前付きパイプのこと（First In First Out）                       |
| 共有メモリ            | 複数プロセスが同じメモリ領域を共有する仕組み                     |
| ソケット              | プロセス間やコンピュータ間でデータを送受信するための接続口       |
| UNIX ドメインソケット | 同一マシン上のプロセス間通信用ソケット                           |
| ストリーム型          | バイト列として連続的にデータを流す方式                           |
| データグラム型        | メッセージ単位でデータを送受信する方式                           |
| mmap                  | ファイルやデバイスをメモリ上にマップする（メモリマッピング）     |
| マッピング            | あるリソースをメモリ空間に対応付けること                         |
| EOF                   | データの終端を示す（End Of File）                                |
| 参照カウント          | あるリソースを開いている fd がいくつあるかを OS が数えた値       |
| デッドロック          | 複数のプロセスが互いに待ち合い、永遠に進まなくなる状態           |
| ブロック              | ある条件が満たされるまで処理が進まず待機すること                 |
| 同期                  | 複数のプロセスが正しい順序でアクセスできるように調整すること     |
| 競合                  | 複数のプロセスが同時に同じデータにアクセスし予期しない結果になる |
| POSIX                 | UNIX 系 OS の標準仕様（Portable Operating System Interface）     |
| クライアント          | サービスを利用する側のプロセス                                   |
| サーバー              | サービスを提供する側のプロセス                                   |
| TCP/IP                | インターネットで使われる通信規約（プロトコル）                   |
| セマフォ              | 同時にアクセスできる数を制限する同期の仕組み                     |
| ミューテックス        | 1つだけがアクセスできるようにする同期の仕組み（相互排他）        |
| API                   | プログラムが使う関数や仕組みの集まり                             |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>パイプ関連</strong>

- [pipe(2) - Linux manual page](https://man7.org/linux/man-pages/man2/pipe.2.html)
  - パイプを作成するシステムコール
- [dup2(2) - Linux manual page](https://man7.org/linux/man-pages/man2/dup2.2.html)
  - ファイルディスクリプタを複製するシステムコール

<strong>FIFO 関連</strong>

- [mkfifo(3) - Linux manual page](https://man7.org/linux/man-pages/man3/mkfifo.3.html)
  - 名前付きパイプを作成する関数
- [fifo(7) - Linux manual page](https://man7.org/linux/man-pages/man7/fifo.7.html)
  - FIFO の概要

<strong>共有メモリ関連</strong>

- [shm_open(3) - Linux manual page](https://man7.org/linux/man-pages/man3/shm_open.3.html)
  - POSIX 共有メモリオブジェクトを開く
- [mmap(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mmap.2.html)
  - メモリマッピングを作成する

<strong>ソケット関連</strong>

- [socket(2) - Linux manual page](https://man7.org/linux/man-pages/man2/socket.2.html)
  - ソケットを作成するシステムコール
- [unix(7) - Linux manual page](https://man7.org/linux/man-pages/man7/unix.7.html)
  - UNIX ドメインソケットの概要
